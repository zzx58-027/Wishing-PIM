当你 await fetch() 时，返回的 Response 对象确实还没有完全下载到服务端，这正是 fetch API 的流式处理优势。
const response = await fetch(url);
// 此时只是收到了响应头，响应体可能还在传输中

// 方式一：使用 ReadableStream
const stream = response.body; // ReadableStream
const reader = stream.getReader();

// 方式二：直接使用响应方法（会等待完整下载）
const blob = await response.blob(); // 等待完整下载
const text = await response.text(); // 等待完整下载

// 不等待完整下载，直接转发流
const response = await fetch(remoteUrl);
return new Response(response.body, {
  headers: {
    'Content-Type': response.headers.get('Content-Type'),
    'Content-Length': response.headers.get('Content-Length'),
  }
});

多源合并下载确实会在客户端表现为一个文件，但是否会数据错乱取决于具体的实现方式和使用场景。
// 这样会导致数据错乱
const urls = [
  'https://example.com/image.jpg',
  'https://example.com/document.pdf',
  'https://example.com/video.mp4'
];

return stream(c, async (stream) => {
  for (const url of urls) {
    const response = await fetch(url);
    await stream.pipe(response.body); // 直接拼接，文件会损坏
  }
});
// 场景：下载被分片的大文件
const chunkUrls = [
  'https://cdn.com/file.part1',
  'https://cdn.com/file.part2', 
  'https://cdn.com/file.part3'
];

return stream(c, async (stream) => {
  for (const url of chunkUrls) {
    const response = await fetch(url);
    await stream.pipe(response.body); // 按顺序合并分片
  }
});

ZIP 打包下载
// 将多个文件打包成 ZIP
import JSZip from 'jszip';

return stream(c, async (stream) => {
  const zip = new JSZip();
  
  for (const [filename, url] of Object.entries(fileMap)) {
    const response = await fetch(url);
    const blob = await response.blob();
    zip.file(filename, blob);
  }
  
  const zipBlob = await zip.generateAsync({type: 'blob'});
  await stream.pipe(zipBlob.stream());
});

### 内存优化考虑
注意： 这种方式会将整个 ZIP 文件加载到内存中，对于大文件可能有内存压力。更优化的方式是使用流式 ZIP 生成：
// 使用流式 ZIP 库（如 archiver）
import archiver from 'archiver';

return stream(c, async (stream) => {
  const archive = archiver('zip', { zlib: { level: 9 } });
  
  // 直接将 archive 流管道到响应
  archive.pipe(stream);
  
  // 添加文件（流式）
  for (const [filename, url] of Object.entries(fileMap)) {
    const response = await fetch(url);
    archive.append(response.body, { name: filename });
  }
  
  await archive.finalize();
});
这样可以避免将整个 ZIP 文件加载到内存中，更适合处理大文件场景。

alova 的 useRequest / Get / Post 等请求方法中，如果你传入的是完整的 URL（包含协议），那么它会忽略掉实例的 baseURL。

在 OpenAPI (Swagger) 里描述 文件 / 流式响应 有几种写法，取决于你希望的返回方式：
content.application/pdf.schema.type = string
format: binary 表示这是个二进制流。
这样 Swagger UI 会显示 "Download file" 按钮。
如果返回的文件类型不固定，比如可能是 PDF / PNG / CSV，可以写：
application/octet-stream 表示 任意二进制流。
3. 流式响应（例如 SSE / 分块传输）

如果接口返回的是 流式数据（比如 SSE，ChatGPT style 流输出），OpenAPI 里没有“stream”这个专门的 type，但通常这么写：

SSE (text/event-stream)
content:
  text/event-stream:
    schema:
      type: string
      example: |
        data: {"id": "msg1", "text": "hello"}
        data: {"id": "msg2", "text": "world"}

NDJSON (一行一条 JSON)
content:
  application/x-ndjson:
    schema:
      type: string
      example: |
        {"id":1,"msg":"hello"}
        {"id":2,"msg":"world"}


📌 注意：OpenAPI 本身不直接支持 声明“这是个无限流”，只能通过 content-type 来表达。
客户端一般就会按 SSE / chunked transfer 去解析。