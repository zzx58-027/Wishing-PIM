å½“ä½  await fetch() æ—¶ï¼Œè¿”å›çš„ Response å¯¹è±¡ç¡®å®è¿˜æ²¡æœ‰å®Œå…¨ä¸‹è½½åˆ°æœåŠ¡ç«¯ï¼Œè¿™æ­£æ˜¯ fetch API çš„æµå¼å¤„ç†ä¼˜åŠ¿ã€‚
const response = await fetch(url);
// æ­¤æ—¶åªæ˜¯æ”¶åˆ°äº†å“åº”å¤´ï¼Œå“åº”ä½“å¯èƒ½è¿˜åœ¨ä¼ è¾“ä¸­

// æ–¹å¼ä¸€ï¼šä½¿ç”¨ ReadableStream
const stream = response.body; // ReadableStream
const reader = stream.getReader();

// æ–¹å¼äºŒï¼šç›´æ¥ä½¿ç”¨å“åº”æ–¹æ³•ï¼ˆä¼šç­‰å¾…å®Œæ•´ä¸‹è½½ï¼‰
const blob = await response.blob(); // ç­‰å¾…å®Œæ•´ä¸‹è½½
const text = await response.text(); // ç­‰å¾…å®Œæ•´ä¸‹è½½

// ä¸ç­‰å¾…å®Œæ•´ä¸‹è½½ï¼Œç›´æ¥è½¬å‘æµ
const response = await fetch(remoteUrl);
return new Response(response.body, {
  headers: {
    'Content-Type': response.headers.get('Content-Type'),
    'Content-Length': response.headers.get('Content-Length'),
  }
});

å¤šæºåˆå¹¶ä¸‹è½½ç¡®å®ä¼šåœ¨å®¢æˆ·ç«¯è¡¨ç°ä¸ºä¸€ä¸ªæ–‡ä»¶ï¼Œä½†æ˜¯å¦ä¼šæ•°æ®é”™ä¹±å–å†³äºå…·ä½“çš„å®ç°æ–¹å¼å’Œä½¿ç”¨åœºæ™¯ã€‚
// è¿™æ ·ä¼šå¯¼è‡´æ•°æ®é”™ä¹±
const urls = [
  'https://example.com/image.jpg',
  'https://example.com/document.pdf',
  'https://example.com/video.mp4'
];

return stream(c, async (stream) => {
  for (const url of urls) {
    const response = await fetch(url);
    await stream.pipe(response.body); // ç›´æ¥æ‹¼æ¥ï¼Œæ–‡ä»¶ä¼šæŸå
  }
});
// åœºæ™¯ï¼šä¸‹è½½è¢«åˆ†ç‰‡çš„å¤§æ–‡ä»¶
const chunkUrls = [
  'https://cdn.com/file.part1',
  'https://cdn.com/file.part2', 
  'https://cdn.com/file.part3'
];

return stream(c, async (stream) => {
  for (const url of chunkUrls) {
    const response = await fetch(url);
    await stream.pipe(response.body); // æŒ‰é¡ºåºåˆå¹¶åˆ†ç‰‡
  }
});

ZIP æ‰“åŒ…ä¸‹è½½
// å°†å¤šä¸ªæ–‡ä»¶æ‰“åŒ…æˆ ZIP
import JSZip from 'jszip';

return stream(c, async (stream) => {
  const zip = new JSZip();
  
  for (const [filename, url] of Object.entries(fileMap)) {
    const response = await fetch(url);
    const blob = await response.blob();
    zip.file(filename, blob);
  }
  
  const zipBlob = await zip.generateAsync({type: 'blob'});
  await stream.pipe(zipBlob.stream());
});

### å†…å­˜ä¼˜åŒ–è€ƒè™‘
æ³¨æ„ï¼š è¿™ç§æ–¹å¼ä¼šå°†æ•´ä¸ª ZIP æ–‡ä»¶åŠ è½½åˆ°å†…å­˜ä¸­ï¼Œå¯¹äºå¤§æ–‡ä»¶å¯èƒ½æœ‰å†…å­˜å‹åŠ›ã€‚æ›´ä¼˜åŒ–çš„æ–¹å¼æ˜¯ä½¿ç”¨æµå¼ ZIP ç”Ÿæˆï¼š
// ä½¿ç”¨æµå¼ ZIP åº“ï¼ˆå¦‚ archiverï¼‰
import archiver from 'archiver';

return stream(c, async (stream) => {
  const archive = archiver('zip', { zlib: { level: 9 } });
  
  // ç›´æ¥å°† archive æµç®¡é“åˆ°å“åº”
  archive.pipe(stream);
  
  // æ·»åŠ æ–‡ä»¶ï¼ˆæµå¼ï¼‰
  for (const [filename, url] of Object.entries(fileMap)) {
    const response = await fetch(url);
    archive.append(response.body, { name: filename });
  }
  
  await archive.finalize();
});
è¿™æ ·å¯ä»¥é¿å…å°†æ•´ä¸ª ZIP æ–‡ä»¶åŠ è½½åˆ°å†…å­˜ä¸­ï¼Œæ›´é€‚åˆå¤„ç†å¤§æ–‡ä»¶åœºæ™¯ã€‚

alova çš„ useRequest / Get / Post ç­‰è¯·æ±‚æ–¹æ³•ä¸­ï¼Œå¦‚æœä½ ä¼ å…¥çš„æ˜¯å®Œæ•´çš„ URLï¼ˆåŒ…å«åè®®ï¼‰ï¼Œé‚£ä¹ˆå®ƒä¼šå¿½ç•¥æ‰å®ä¾‹çš„ baseURLã€‚

åœ¨ OpenAPI (Swagger) é‡Œæè¿° æ–‡ä»¶ / æµå¼å“åº” æœ‰å‡ ç§å†™æ³•ï¼Œå–å†³äºä½ å¸Œæœ›çš„è¿”å›æ–¹å¼ï¼š
content.application/pdf.schema.type = string
format: binary è¡¨ç¤ºè¿™æ˜¯ä¸ªäºŒè¿›åˆ¶æµã€‚
è¿™æ · Swagger UI ä¼šæ˜¾ç¤º "Download file" æŒ‰é’®ã€‚
å¦‚æœè¿”å›çš„æ–‡ä»¶ç±»å‹ä¸å›ºå®šï¼Œæ¯”å¦‚å¯èƒ½æ˜¯ PDF / PNG / CSVï¼Œå¯ä»¥å†™ï¼š
application/octet-stream è¡¨ç¤º ä»»æ„äºŒè¿›åˆ¶æµã€‚
3. æµå¼å“åº”ï¼ˆä¾‹å¦‚ SSE / åˆ†å—ä¼ è¾“ï¼‰

å¦‚æœæ¥å£è¿”å›çš„æ˜¯ æµå¼æ•°æ®ï¼ˆæ¯”å¦‚ SSEï¼ŒChatGPT style æµè¾“å‡ºï¼‰ï¼ŒOpenAPI é‡Œæ²¡æœ‰â€œstreamâ€è¿™ä¸ªä¸“é—¨çš„ typeï¼Œä½†é€šå¸¸è¿™ä¹ˆå†™ï¼š

SSE (text/event-stream)
content:
  text/event-stream:
    schema:
      type: string
      example: |
        data: {"id": "msg1", "text": "hello"}
        data: {"id": "msg2", "text": "world"}

NDJSON (ä¸€è¡Œä¸€æ¡ JSON)
content:
  application/x-ndjson:
    schema:
      type: string
      example: |
        {"id":1,"msg":"hello"}
        {"id":2,"msg":"world"}


ğŸ“Œ æ³¨æ„ï¼šOpenAPI æœ¬èº«ä¸ç›´æ¥æ”¯æŒ å£°æ˜â€œè¿™æ˜¯ä¸ªæ— é™æµâ€ï¼Œåªèƒ½é€šè¿‡ content-type æ¥è¡¨è¾¾ã€‚
å®¢æˆ·ç«¯ä¸€èˆ¬å°±ä¼šæŒ‰ SSE / chunked transfer å»è§£æã€‚